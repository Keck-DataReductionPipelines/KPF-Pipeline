## primitives from modules.
from modules.order_trace.src.order_trace import OrderTrace
from modules.spectral_extraction.src.order_rectification import OrderRectification
from modules.spectral_extraction.src.spectral_extraction import SpectralExtraction
from modules.radial_velocity.src.radial_velocity_init import RadialVelocityInit
from modules.radial_velocity.src.radial_velocity import RadialVelocity
from modules.radial_velocity.src.radial_velocity_reweighting_ref import RadialVelocityReweightingRef
from modules.radial_velocity.src.radial_velocity_reweighting import RadialVelocityReweighting
from modules.ca_hk.src.ca_hk_extraction import CaHKExtraction
from modules.quicklook.src.quick_prim import Quicklook
from modules.Utils.string_proc import str_replace
from modules.Utils.string_proc import date_from_kpffile
from modules.Utils.data_handler import ExtCopy
from modules.Utils.data_handler import FromCSV
from modules.Utils.data_handler import GetHeaderValue
from modules.Utils.data_handler import SetHeaderValue
from modules.Utils.data_handler import SelectObs
from modules.Utils.orientation_ref_reader import OrientationReference
from modules.Utils.overscan_subtract import OverscanSubtraction
from modules.image_processing.src.image_process import ImageProcessing
from modules.order_trace.src.order_mask import OrderMask
from modules.spectral_extraction.src.bary_corr import BaryCorrTable
from database.modules.query_db_nearest_master_files.src.query_db_nearest_master_files_framework import QueryDBNearestMasterFilesFramework
from database.modules.query_db_one_nearest_master_file.src.query_db_one_nearest_master_file_framework import QueryDBOneNearestMasterFileFramework

# set the flags for each process
# note: no rv reweighting is made here.
#       do_rv_reweighting will be reset after the method to produce the ratio table for reweighting is fixed later.

do_l0_to_2d = config.ARGUMENT.do_l0_to_2d
do_order_trace = config.ARGUMENT.do_order_trace
do_spectral_extraction = config.ARGUMENT.do_spectral_extraction
do_rv = config.ARGUMENT.do_rv
do_rv_reweighting = config.ARGUMENT.do_rv_reweighting
do_hk = config.ARGUMENT.do_hk
do_qlp = config.ARGUMENT.do_qlp
do_bk_subtraction = config.ARGUMENT.do_bk_subtraction
do_bc = config.ARGUMENT.do_bc

# data type of data model, 'KPF' for kpf data.
data_type = config.ARGUMENT.data_type
# if overwrite the existing data
overwrite = config.ARGUMENT.overwrite

# if copy wavelength solution data to L1 from file samples with wls data.
do_sp_wavecopy = config.ARGUMENT.do_wavecopy_in_sp

# file path for lev0 and lev1 data
lev0_file_path = ""
lev1_file_path = ""

##  reset process flags for the process of 2D to L1, L1 to L2, L2 to L2 reweighting for watch mode or non-watch mode ##
#   watch mode: command is with "--watch /data/L0|2D|L1/yyyymmdd".
#      => context.watch == True,  context.date_dir: yyyymmdd, context.file_path: /data/2D/yyyymmdd
#   non-watch mode:  Command is with "--date /data/L0|2D|L1/yyyymmdd" or "--date yyyymmdd".
#      => context.watch == False,  context.date_dir: yyyymmdd, context.file_path: /data/2D/yyyymmdd or yyyymmdd

if context.watch:
	sel_obsid = context.date_dir
	file_path = context.file_path

	# do spectral extraction if 2D data is made after watching L0, then do 2D->l1->l2
	if 'L0' in file_path:
		lev0_file_path = str_replace(file_path, 'L0', '2D')
		lev0_file_path = str_replace(lev0_file_path, '.fits', '_2D.fits')
		lev1_file_path = str_replace(file_path, 'L0', 'L1')
		do_order_trace = False

	# do spectral extraction if 2D data is watched, do 2D->l1->l2
	if '2D' in file_path:
		lev0_file_path = file_path
		lev1_file_path = str_replace(file_path, '2D', 'L1')
		do_l0_to_2d = False
		do_order_trace = False

	# do rv if L1 data is watched, do l1->l2
	if 'L1' in file_path:
		lev1_file_path = file_path
		lev0_file_path = str_replace(file_path, 'L1', '2D')
		do_order_trace = False
		do_spectral_extraction = False
		do_l0_to_2d = False
		do_bc = False
		do_hk = False

else:
	sel_obsid = context.date_dir
	file_path = context.file_path

	# if not including 2D or L1, the flag is set as what kpf_drp.cfg sets.
	# if including 2D, do l0->l1->l2
	if '2D' in file_path:
		do_order_trace = False
		do_spectral_extraction = True
		do_rv = True
		# do_rv_reweighting = True

	# if including L1, do l1->l2
	if 'L1' in file_path:
		do_order_trace = False
		do_spectral_extraction = False
		do_bc = False
		do_hk = False
		do_rv = True
		# do_rv_reweighting = True

	# if doing reweighted L2
	if 'L2' in file_path:
		do_order_trace = False
		do_spectral_extraction = False
		do_rv = False
		do_bc = False
		do_hk = False
		# do_rv_reweighting = True

## set path to output and input (for 2D, flat and masters) data
# date dir for 2D, masters input and L1 and L2 output.
date_dir = sel_obsid + '/'

# flat_file_pattern = config.ARGUMENT.flat_file
# date dir for flat file
# use the full path of flat file defined in config instead
# date_dir_flat = date_from_kpffile(flat_file_pattern, startswith='kpf_')
# if date_dir_flat == None:
#	date_dir_flat = date_dir
# else:
#	date_dir_flat = date_dir_flat + '/'

output_dir = config.ARGUMENT.output_dir
input_2d_dir = config.ARGUMENT.input_dir_root + date_dir
# input_2d_dir_flat = config.ARGUMENT.masters_dir + date_dir_flat
masters_data_dir = output_dir + "masters/"

## general purpose variables
ccd_list = config.ARGUMENT.ccd_list
lev0_stem_suffix = config.ARGUMENT.output_lev0_suffix
lev1_stem_suffix = config.ARGUMENT.output_lev1_suffix
lev2_stem_suffix = config.ARGUMENT.output_lev2_suffix
fits_ext = '.fits'
csv_ext = '.csv'

poly_degree = config.ARGUMENT.fitting_poly_degree
ccd_idx=config.ARGUMENT.ccd_idx

start_order= config.ARGUMENT.start_order
rect_method = config.ARGUMENT.rectification_method
extract_method = config.ARGUMENT.extraction_method
orderlet_names = config.ARGUMENT.orderlet_names
flat_rect = '_'+rect_method

## full path for wavelength solution sample files for each fiber
wls_list = config.ARGUMENT.wls_fits
wave_fits = []
for wls in wls_list:
	wave_fits = wave_fits + [output_dir + wls]


## do L0->2D conversion for watch mode
if context.watch and do_l0_to_2d:
    invoke_subrecipe("./recipes/watchfor_kpf_l0.recipe")


# Override wave_fits list with optional database query for nearest WLS master file.
do_db_query_for_one_nearest_wls_master_file = config.ARGUMENT.do_db_query_for_one_nearest_wls_master_file
date_dir_db_query = context.date_dir
cal_file_level = config.ARGUMENT.cal_file_level
contentbitmask = config.ARGUMENT.contentbitmask
cal_type_pairs = config.ARGUMENT.cal_type_pairs
max_cal_file_age = config.ARGUMENT.max_cal_file_age

if do_db_query_for_one_nearest_wls_master_file and do_spectral_extraction:
	db_wls_exit_code = 1
	for cal_type_pair in cal_type_pairs:
		if db_wls_exit_code != 0:
			query_one_nearest_master_file_list = QueryDBOneNearestMasterFileFramework(data_type,
																					date_dir_db_query,
																					cal_file_level,
																					contentbitmask,
																					cal_type_pair,
																					max_cal_file_age)

			db_wls_exit_code = query_one_nearest_master_file_list[0]

			if db_wls_exit_code == 0:

				db_wls_rec = query_one_nearest_master_file_list[1]
				db_wls_master_file = db_wls_rec[6]
				wave_fits = []
				for wls in wls_list:
					wave_fits = wave_fits + [output_dir + db_wls_master_file]

				wave_fits = []
				for wls in wls_list:
					wave_fits = wave_fits + [output_dir + db_wls_master_file]

				

#### variables related to input/output and process conditions for order_trace, spectral extraction, CA-HK, rv and qlp

## for order trace:  input, output and image area
#    data_row_range, data_col_range: image area for order trace process:
#       [n1, n2] means from n1-th row (or column) to the n2-th row (or column).
#       if n1 or n2 is negative, it means counting from the right end (the last one).
#    origin: origin of the image to be processed
data_row_range = [0, -1]
data_col_range = [0, -1]
origin = [data_col_range[0], data_row_range[0]]

#    lev0_flat_pattern: input flat fits => /data/2D/<date_dir_flat>/<flat_file>
#    output_order_trace: output path => /data/order_trace/<date_dir_flat>/
#lev0_flat_pattern = input_2d_dir_flat + flat_file_pattern + fits_ext
lev0_flat_pattern = config.ARGUMENT.flat_file
# output_order_trace = output_dir + config.ARGUMENT.output_trace + date_dir_flat
# use the full path of ourder trace files defind in config
output_order_trace = config.ARGUMENT.order_trace_files

## for spectral extraction: input and output
#    lev0_science_pattern: if watch mode => a single 2D file, /data/2D/<date_dir>/<a single watched 2D fits>
#                          if non-watch mode => a path pattern of 2D files => /data/2D/<date_dir>/*.fits
#    output_extraction: output path => /data/L1/<date_dir>/
#    wave_to_ext: extensions in L1 containing wavelength solution data for each fiber.
#    orderlet_widths_ccds: trace widths per orderlet per ccd to replace the trace widths from the order trace process

if lev0_file_path:
    lev0_science_pattern = lev0_file_path
else:
    lev0_science_pattern = input_2d_dir + '*' + fits_ext
output_extraction = output_dir + config.ARGUMENT.output_extraction + date_dir
wave_to_ext = config.ARGUMENT.wave_to_ext
orderlet_widths_ccds = config.ARGUMENT.orderlet_widths_ccds

#    output_clip: only needed when rect_method != norect: directory containing files with polygon clipping information
#                  for faster vertical or normal rectification => /data/L1/clip_np/vertical(or normal)/
#    orders_per_ccd: total order for each ccd.
#    s_bary_idx: start index in bary corr table for each ccd

if rect_method != 'norect':
	output_clip = output_extraction + config.ARGUMENT.output_clip + rect_method + '/'
else:
	output_clip = None
orders_per_ccd = config.ARGUMENT.orders_per_ccd
s_bary_idx = [0, orders_per_ccd[0]]

## for radial velocity and rv reweighting input and output
#    input_lev1_pattern: if watch mode => a single L1 file, /data/L1.<a single watched L1 fits>
#                        if non-watch mode => a path pattern of L1 files,  /data/L1/<date_dir>/*.fits
#    output_rv, output_rv_rw: L2 output for rv and rv reweighting.
#    bc_path: path to files containing barycentric correction of a star over a period
#    lev2_pattern: a path pattern of L2 files produced by rv and before rv reweighting => /data/L2/<data_dir>/*_L2.fits
if lev1_file_path:
	input_lev1_pattern = lev1_file_path
else:
	input_lev1_pattern = output_extraction + '*' + lev1_stem_suffix + fits_ext
output_rv = output_dir + config.ARGUMENT.output_rv + date_dir
output_rv_rw = output_rv + config.ARGUMENT.output_rv_reweighting
bc_path = output_dir + config.ARGUMENT.output_barycorr
lev2_pattern = output_rv + '*' + lev2_stem_suffix + fits_ext

reweighting_method = config.ARGUMENT.reweighting_method
data_ext_rv = config.ARGUMENT.orderlet_names_rv
ccf_ext_names = config.ARGUMENT.ccf_ext
rv_ext = config.ARGUMENT.rv_ext
is_rv_cal = config.ARGUMENT.rv_correct_by_cal
if 'static' in reweighting_method:
	static_ccf_ratio = config.ARGUMENT.static_ccf_ratio
else:
	static_ccf_ratio = None

## for ca_hk input 2D  and output L1, ca_hk trace and wavelength solution tables
#    input_hk_pattern: for watch mode =>  a single 2D file,
#                      for non-watch mode => a a path pattern of 2D files for <data_dir>
#                      (same 2D sources as the input for spectral extraction)
#    hk_fiber_list: CA-HK spectrometer fibers
#    hk_spec_exts: extensions containing 1D extracted spectrum for the fibers in hk_fiber_list
#    hk_wave_exts: extensions containing wavelength solution for the fibers in hk_fiber_list
#    hk_trace_table: CA-HK trace file for spectrum extraction, /data/masters/<xxx.csv>
#    hk_wavelength_tables: wavelength solution files for each fiber, [/data/masters/<xxx.csv>,...]
input_hk_pattern = lev0_science_pattern

## path containing ca_hk trace file and wavelength table
input_hk_data_dir = output_dir
hk_fiber_list = config.ARGUMENT.hk_fiber_list
hk_spec_exts = config.ARGUMENT.hk_extract_exts
hk_wave_exts = config.ARGUMENT.hk_wave_exts
hk_trace_table = input_hk_data_dir + config.ARGUMENT.hk_trace_path
hk_wavelength_csvs = config.ARGUMENT.hk_wavelength_path
hk_wavelength_tables = []
for hk_w in hk_wavelength_csvs:
	hk_wavelength_tables = hk_wavelength_tables + [input_hk_data_dir + hk_w]

## for qlp
output_qlp =  output_dir + config.ARGUMENT.output_qlp + date_dir + "/"
end_of_night_summary = False

####  process for order trace, spectral extraction and CA-HK, radial velocity, and qlp
## qlp are invoked at the following processing spots,
#  - before spectral extraction
#  - after spectral extraction
#  - after radial velocity

## do order trace
#  description: find traces from L0 flat data for each ccd, and produce rectified L0 flat data.
#  input: L0 flat
#  output: order trace result in csv and rectiified L0 flat
#  variable highlights:
#    flat_stem: file basename (flat_stem) from flat file path
#    trace_list: list containing order trace result file for each ccd.
#                i.e. [/data/order_trace/<date_dir_flat>/<flat_stem>_GREEN_CCD.csv, ... /<flat_stem>_RED_CCD.csv]
#    b_all_traces: a boolean to indicate if the order trace result for all ccds are produced successfully (or exists).
#    lev0_flat_rect: KPF0 instance containing rectified L0 flat data (the image with straighten traces)
#    output_lev0_flat_rect: fits file for lev0_flat_rect, /data/order_trace/<date_dir_flat>/<flat_stem>_<rect_method>.fits
#  primitives:
#    OrderTrace: order trace
#    OrderRectification: order trace rectification

if "*" in lev0_flat_pattern:
	# for masters we need to add the date_dir part in the recipe because the config
	# doesn't know about date_dir
	ll0 = output_dir + date_dir + lev0_flat_pattern
else:
	ll0 = lev0_flat_pattern
input_flat_file = find_files(ll0)[0]
_, short_flat_file = split(input_flat_file)
flat_stem, flat_ext = splitext(short_flat_file)

trace_list = []
b_all_traces = False
lev0_flat_rect = None

if do_order_trace:
	flat_data = None

	if exists(input_flat_file):
		# read in flat fits file to produce KPF0 instance
		flat_data = kpf0_from_fits(input_flat_file)
		b_all_traces = True

		# loop to do order trace per ccd in case the order trace result file doesn't exist, and output to trace_list
		for idx in ccd_idx:
			ccd = ccd_list[idx]
			# get order trace file name defined in config file
			# output_lev0_trace_csv = output_order_trace + flat_stem + '_' + ccd + csv_ext
			output_lev0_trace_csv = output_order_trace[idx] 
			trace_list = trace_list + [output_lev0_trace_csv]
			if not exists(output_lev0_trace_csv):
				order_result_data = OrderTrace(flat_data, data_extension=ccd + '_STACK',
					result_path=output_lev0_trace_csv, is_output_file=True,
					data_col_range=data_col_range, data_row_range=data_row_range,
					fitting_poly_degree=poly_degree)

			b_all_traces = b_all_traces and exists(output_lev0_trace_csv)

	# output_lev0_flat_rect = output_order_trace + flat_stem + flat_rect + fits_ext
	output_lev0_flat_rect = str_replace(input_flat_file, fits_ext, flat_rect+fits_ext)
	lev0_flat_rect = flat_data

	# generate rectification result to flat level0 to avoid repeating the same process in spectral extraction

	if not exists(output_lev0_flat_rect):
		# do rectification on the flat data in case the order trace result files for all ccds exist.
		# b_lev0_rect: a boolean to determine if continuing to do OrderRectification and produce output_lev0_flat_rect

		b_lev0_rect = lev0_flat_rect != None and b_all_traces
		if b_lev0_rect:
			for idx in ccd_idx:
				ccd = ccd_list[idx]
				# no clip file if rect_method == 'norect'
				# or clip_file = output_clip + flat_stem + '_' + ccd
				clip_file = None
				trace_file = trace_list[idx]

				if b_lev0_rect:
					lev0_flat_rect = OrderRectification(None, lev0_flat_rect,
							orderlet_names=orderlet_names[idx],
							trace_file=trace_file, data_extension=ccd,
							rectification_method=rect_method,
							clip_file=clip_file,
							origin=origin, poly_degree=poly_degree)

				# if lev0_flat_rect is not produced, the order rectfication stops here.
				b_lev0_rect = b_lev0_rect and lev0_flat_rect != None
			if b_lev0_rect:
				result = to_fits(lev0_flat_rect, output_lev0_flat_rect)

## do spectral extraction including CA-HK extraction
#  description: do spectrum extraction based on extraction method (summ or optimal) per fiber per ccd and
#               spectral extraction from CA-HK spectrometer fibers.
#               copy wavelength solution data from wls sample files to produced L1 data.
#  input: 2D fits
#  output: L1 fits
#  variable highlights:
#    lev1_stem: name base of L1 file to produce.
#    output_lev1_file: path of produced L1 file,  /data/L1/<date_dir>/<lev1_stem>_L1.fits
#    lev1_list: a list containing the path of L1 files produced by either spectral extraction or ca_hk extraction.
#
#    for spectral extraction:
#      output_lev0_flat_rect: fits file with rectified L0 flat data
#      lev0_flat_rect: KPF0 instance for 'output_lev0_flat_rect'
#      b_all_traces: a boolean to indicate if the order trace results for all ccds exist.
#      trace_list: list containing order trace result file for each ccd.
#                  [/data/order_trace/<date_dir_flat>/<flat_stem>_GREEN_CCD.csv (or <flat_stem>_RED_CCD.csv)]
#      b_level1_sp: a boolean to indicate if spectral extraction for each L0 is successful.
#      op_data: KPF1 instance containing spectral extraction result which is added into op_data extension by extension
#               per specified extension list (order_names) in each ccd iteration.
#      wavecal_data: KPF1 instance per wls sample file.
#    for ca_hk:
#      hk_dark_data: KPF0 for dark data
#      hk_bias_data: KPF0 for bias data
#  primitives:
#    SpectralExtraction: spectral extraction
#    ExtCopy: extension copy from the extension of one data model instance to the extension of another
#             (or the same) data model instance.
#    CaHKExtraction: CA HK extraction.
#

lev1_list = []

if do_spectral_extraction or do_hk or do_bc:
	lev0_flat_rect = None

	# prepare trace files and rectified L0 flat data for spectral extraction
	if do_spectral_extraction:
		# existence of flat and trace files
		# output_lev0_flat_rect = output_order_trace + flat_stem + flat_rect + fits_ext
		output_lev0_flat_rect = str_replace(input_flat_file, fits_ext, flat_rect+fits_ext)
		if exists(output_lev0_flat_rect):
			lev0_flat_rect = kpf0_from_fits(output_lev0_flat_rect, data_type=data_type)

		if not trace_list:
			b_all_traces = True
			for idx in ccd_idx:
				# lev0_trace_csv = output_order_trace + flat_stem + '_' + ccd_list[idx] + csv_ext
				lev0_trace_csv = output_order_trace[idx]
				trace_list = trace_list + [lev0_trace_csv]
				b_all_traces = b_all_traces and exists(lev0_trace_csv)

	# prepare bias, dark data for ca_hk
	if do_hk:
		hk_dark_data = config.ARGUMENT.hk_dark_fits
		hk_bias_data = config.ARGUMENT.hk_bias_fits
		if hk_dark_data:
			hk_dark_data = kpf0_from_fits(input_hk_data_dir + hk_dark_data, data_type = data_type)
		else:
			hk_dark_data = None

		if hk_bias_data:
			hk_bias_data = kpf0_from_fits(input_hk_data_dir + hk_bias_data, data_type=data_type)
		else:
			hk_bias_data = None

	# loop through ccd and L0 to do spectral extraction
	for input_lev0_file in find_files(lev0_science_pattern):
		# lev0_data is KPF0 instance for input_lev0_file
		lev0_data = kpf0_from_fits(input_lev0_file, data_type=data_type)
		_, short_lev0_file = split(input_lev0_file)
		lev1_stem, lev1_ext = splitext(short_lev0_file)

		# lev1_stem is w/o "_2D" suffix
		if lev0_stem_suffix != None:
			if lev0_stem_suffix in lev1_stem:
				lev1_stem = str_replace(lev1_stem, lev0_stem_suffix, "")
		output_lev1_file = output_extraction + lev1_stem + lev1_stem_suffix + fits_ext

		# produce level 1 by spectral extraction if overwrite or L1 file doesn't exist
		if overwrite or not exists(output_lev1_file):
			b_level1_sp = False

			# do spectral extraction if do_spectral_extraction, rectified flat data existing and all trace results exist.
			if do_spectral_extraction and (lev0_flat_rect != None) and b_all_traces:
				b_level1_sp = True


			if do_qlp and (b_level1_sp or do_hk or do_bc):
				Quicklook(lev0_data, output_qlp, end_of_night_summary)

			# loop through ccd to do spectral extraction
			if b_level1_sp:
				# do background subtraction
				if do_bk_subtraction:
					order_mask = None
					# create order mask for background subtraction
					for idx in ccd_idx:
						if orderlet_widths_ccds:
							orderlet_widths = orderlet_widths_ccds[idx]
						else:
							orderlet_widths = []
						order_mask = OrderMask(lev0_data, order_mask, orderlet_names=orderlet_names[idx],
								start_order=start_order[idx], trace_file=trace_list[idx],
								data_extension=ccd_list[idx],
								orderlet_widths=orderlet_widths)
					# update L0 by background subtraction
					if order_mask != None:
						lev0_data = ImageProcessing(lev0_data, order_mask, ccd_list, data_type, None)

				op_data = None
				for idx in ccd_idx:
					ccd = ccd_list[idx]
					order_names = orderlet_names[idx]
					trace_file = trace_list[idx]

					clip_file = None

					op_data = SpectralExtraction(lev0_data, lev0_flat_rect, op_data,
								orderlet_names=order_names,
								orderlets_on_image=order_names,
								total_order_per_ccd=orders_per_ccd,
								start_order=start_order[idx],
								ccd_index = idx,
								rectification_method=rect_method, extraction_method=extract_method,
								clip_file=clip_file, data_extension=ccd, trace_file=trace_file)


				if op_data != None:
					result = to_fits(op_data, output_lev1_file)

			# copy wls to the proper extension of lev1 data
			if do_sp_wavecopy and exists(output_lev1_file):
				output_data = kpf1_from_fits(output_lev1_file, data_type = data_type)
				for idx in ccd_idx:
					if wave_fits[idx] != None and exists(wave_fits[idx]):
						wavecal_data = kpf1_from_fits(wave_fits[idx], data_type=data_type)
						for ext in wave_to_ext[idx]:
							ExtCopy(wavecal_data, ext, ext, to_data_model=output_data)

				SetHeaderValue(output_data, 'WLSFILE', wave_fits[0])
				result = to_fits(output_data, output_lev1_file)

			if do_bc and exists(output_lev1_file):
				# add bary correction result to existing L1 file
				output_data = kpf1_from_fits(output_lev1_file, data_type = data_type)
				t_order = 0
				for idx in ccd_idx:
					t_order = t_order + orders_per_ccd[idx]

				# all extensions of same ccd in wls has the same data
				for idx in ccd_idx:
					output_data = BaryCorrTable(lev0_data, output_data, t_order, orders_per_ccd[idx],
								start_bary_index=s_bary_idx[idx], wls_ext=wave_to_ext[idx][0])
				result = to_fits(output_data, output_lev1_file)

			# do ca_hk extraction
			if do_hk:
				# add ca_hk extraction result to existing L1 file or create a new L1 file if L1 file doesn't exist
				if not exists(output_lev1_file):
					output_data = None
				else:
					output_data = kpf1_from_fits(output_lev1_file, data_type = data_type)

				output_data = CaHKExtraction(lev0_data, hk_trace_table, hk_fiber_list, output_data, output_exts=hk_spec_exts,
						output_wave_exts=hk_wave_exts,
						dark=hk_dark_data, wave_files=hk_wavelength_tables)

				if output_data != None:
					result = to_fits(output_data, output_lev1_file)

			if exists(output_lev1_file):
				lev1_list = lev1_list + [output_lev1_file]
				if do_qlp:
					Quicklook(lev0_data, output_qlp, end_of_night_summary)

## do radial velocity or rv reweighting:
#  description: do radial velocity on the specified extensions of L1 data and produce L2 data.
#               do radial velocity reweighting based on the ratio table for the reweighting.
#               (note: method for radial velocity reweighting will be further finalized.)
#  input: L1 fits
#  output: L2 fits
#  variable highlights:
#    rv_star_dir: the directory containing star config file.
#    area_def: list of list in which the order range and range along x-axis like [start_order, end_order, start_x, end_x],
#              for each ccd is defined for rv process.
#    selected_lev1_files: list of L1 files for rv process
#    rv_data: KPF2 instance containing rv result, the rv result is added into rv_data extension by extension per specified
#             extension list (data_ext_rv) in each ccd iteration.
#    output_lev2_file: L2 output file for rv_data, /data/L2/<date_dir>/<basename>_L2.fits
#
#  primitives:
#    RadialVelocityInit: do rv init on each L1 input.
#    RadialVelocity: do radial velocity per ccd per L1 data.
#
rv_test = do_rv or do_rv_reweighting
if do_rv or do_rv_reweighting:
	rv_star_dir = masters_data_dir

	# L1 area to be processed
	area_def = [[0, orders_per_ccd[0]-1, 500, -500], [0, orders_per_ccd[1]-1, 500, -500]]

	if not lev1_list:
		lev1_list = find_files(input_lev1_pattern)

	# select L1 files from lev1_list by using SelectObs, a primitive to filter files from a file list based on selection rule, selection_ref.
	# all files in lev1_list are selected if list_socal is None.
	if do_rv:
		list_socal = None
		selected_lev1_files = SelectObs(lev1_list, selection_ref=list_socal, observation_id=sel_obsid)
	else:
		selected_lev1_files = []

	ratio_refs = []
	if 'static' in reweighting_method and do_rv_reweighting:
		for idx in ccd_idx:
			ccf_ratio_file = output_dir + static_ccf_ratio[idx]
			t_segment = area_def[idx][1] -  area_def[idx][0] + 1
			ratio_ref = RadialVelocityReweightingRef(None, reweighting_method,
							t_segment, cf_hdu_name=ccf_ext_names[idx],
							is_ratio_data = True,
							ccf_ratio_file=ccf_ratio_file, ccf_start_index=area_def[idx][0])
			ratio_refs = ratio_refs + [ratio_ref]

	# iterating the loop to do rv on each L1 from the list
	for input_lev1_file in selected_lev1_files:
		_, short_lev1 = split(input_lev1_file)
		short_lev2 = str_replace(short_lev1, lev1_stem_suffix, lev2_stem_suffix)
		output_lev2_file = output_rv + short_lev2

		# do rv if oeverwrite or L2 output doesn't exist
		rv_data = None
		if overwrite or not exists(output_lev2_file):
			lev1_data = kpf1_from_fits(input_lev1_file, data_type=data_type)
			rv_init = RadialVelocityInit(start_time="2021-03-01", l1_data=lev1_data, bc_corr_path=bc_path, test_data_path=rv_star_dir)

			if rv_init != None:
				for idx in ccd_idx:
					ratio_ref = None
					# rewighting if the reweighted L2 at the same directory as unweighted L2.
					if ratio_refs and output_rv == output_rv_rw:
						ratio_ref = ratio_refs[idx]

					rv_data = RadialVelocity(lev1_data, rv_init, rv_data,
						data_ext_rv[idx], ccf_ext=ccf_ext_names[idx], rv_ext=rv_ext,
						area_def=area_def[idx], start_seg=area_def[idx][0], end_seg=area_def[idx][1],
						rv_set=idx, ccf_engine='c', start_bary_index=s_bary_idx[idx], rv_correction_by_cal=is_rv_cal,
						reweighting_method=reweighting_method, input_ref=ratio_ref)
				if rv_data != None:
					result = to_fits(rv_data, output_lev2_file)

		if do_qlp:
			# get lev0 w/o _2D suffix
			short_lev0 = str_replace(short_lev1, lev1_stem_suffix, "")
			input_lev0_file = input_2d_dir + short_lev0
			if not find_files(input_lev0_file):
				short_lev0 = str_replace(short_lev1, lev1_stem_suffix, lev0_stem_suffix)
				input_lev0_file = input_2d_dir + short_lev0
			if find_files(input_lev0_file):
				lev0_data = kpf0_from_fits(input_lev0_file,data_type=data_type)
				Quicklook(lev0_data, output_qlp, end_of_night_summary)


		# do reweighting on each L2 in case the rewighting directory is different from the unweighted L2.
		if 'static' in reweighting_method and do_rv_reweighting:
			if exists(output_lev2_file) and output_rv != output_rv_rw:
				lev2_rv = kpf2_from_fits(output_lev2_file, data_type=data_type)
				reweighted_output = output_rv_rw + short_lev2
				for idx in ccd_idx:
					ratio_ref = None
					if ratio_refs:
						ratio_ref = ratio_refs[idx]

					if ratio_ref is not None:
						t_segment = area_def[idx][1] -  area_def[idx][0] + 1
						lev2_rv = RadialVelocityReweighting(lev2_rv, reweighting_method, ratio_ref,
								t_segment, ccf_ext=ccf_ext_names[idx],
								rv_ext=rv_ext,  rv_ext_idx=idx, ccf_start_index=area_def[idx][0])
				if lev2_rv is not None:
					result = to_fits(lev2_rv, reweighted_output)

